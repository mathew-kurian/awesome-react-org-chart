!function(t){var e={};function i(o){if(e[o])return e[o].exports;var n=e[o]={i:o,l:!1,exports:{}};return t[o].call(n.exports,n,n.exports,i),n.l=!0,n.exports}i.m=t,i.c=e,i.d=function(t,e,o){i.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:o})},i.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},i.t=function(t,e){if(1&e&&(t=i(t)),8&e)return t;if(4&e&&"object"==typeof t&&t&&t.__esModule)return t;var o=Object.create(null);if(i.r(o),Object.defineProperty(o,"default",{enumerable:!0,value:t}),2&e&&"string"!=typeof t)for(var n in t)i.d(o,n,function(e){return t[e]}.bind(null,n));return o},i.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return i.d(e,"a",e),e},i.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},i.p="",i(i.s="./spec/spec.ts")}({"./spec/spec.ts":function(t,e,i){"use strict";i.r(e);class o{constructor(){this._branchSpacing=0,this.DefaultAssistantLayoutStrategyId=null,this.DefaultLayoutStrategyId=null,this.BranchSpacing=50,this.LayoutStrategies=new Map}get BranchSpacing(){return this._branchSpacing}set BranchSpacing(t){if(t<0)throw new Error("Cannot be negative");this._branchSpacing=t}RequireDefaultLayoutStrategy(){const t=this.DefaultLayoutStrategyId;if(!t)throw new Error("DefaultLayoutStrategyId is null or not valid");const e=this.LayoutStrategies.get(t);if(!e)throw new Error("DefaultLayoutStrategyId is null or not valid");return e}RequireDefaultAssistantLayoutStrategy(){const t=this.DefaultAssistantLayoutStrategyId;if(!t)throw new Error("DefaultLayoutStrategyId is null or not valid");const e=this.LayoutStrategies.get(t);if(!e)throw new Error("DefaultLayoutStrategyId is null or not valid");return e}}class n{constructor(){this._visualTree=null,this._boxes=null,this.LayoutSettings=new o}get Boxes(){if(null==this._boxes)throw Error("Boxes is null");return this._boxes}set Boxes(t){this._visualTree=null,this._boxes=t}get VisualTree(){return this._visualTree}set VisualTree(t){this._visualTree=t}}class r{constructor(t,e){this.Width=t,this.Height=e}}class s{get IsDataBound(){return!!this.DataId}static Special(t,e,i){return new s(null,t,e,!0,i,!1)}constructor(t,e,i,o,n,s){if(0==e)throw new Error("Invalid "+e);this.Id=e,this.ParentId=i,this.DataId=t,this.IsSpecial=o,this.IsAssistant=s,this.DisableCollisionDetection=n,this.AssistantLayoutStrategyId=null,this.LayoutStrategyId=null,this.IsCollapsed=!1,this.Size=new r(0,0)}}s.None=-1;class a{constructor(t){this._lastBoxId=0,this._boxesById=new Map,this._boxesByDataId=new Map,this.SystemRoot=null,t&&this.ReloadBoxes(t)}get BoxesById(){return this._boxesById}get BoxesByDataId(){return this._boxesByDataId}ReloadBoxes(t){this._boxesByDataId.clear(),this._boxesById.clear(),this._lastBoxId=0,this.SystemRoot=s.Special(++this._lastBoxId,s.None,!0),this._boxesById.set(this.SystemRoot.Id,this.SystemRoot);const e=new Map;for(const i of t.AllDataItemIds)e.set(i,this.NextBoxId());const i=t.GetDataItemFunc;for(const o of t.AllDataItemIds){const n=o?t.GetParentKeyFunc(o):null,r=n?e.get(n):this.SystemRoot.Id,s=e.get(o);null!=s&&null!=r&&this._AddBox(o,s,r,i(o).IsAssistant)}}AddBox(t,e,i){return this._AddBox(t,this.NextBoxId(),e,i)}_AddBox(t,e,i,o){const n=new s(t,e,i,!1,!1,o);return this._boxesById.set(n.Id,n),n.DataId&&this._boxesByDataId.set(n.DataId,n),n}NextBoxId(){return this._lastBoxId++,this._lastBoxId}}var l,h;(h=l||(l={}))[h.Idle=0]="Idle",h[h.Preparing=1]="Preparing",h[h.PreprocessVisualTree=2]="PreprocessVisualTree",h[h.VerticalLayout=3]="VerticalLayout",h[h.HorizontalLayout=4]="HorizontalLayout",h[h.ConnectorsLayout=5]="ConnectorsLayout",h[h.Completed=6]="Completed";var u,S,d=l;class g{constructor(t,e){this.X=t,this.Y=e}MoveH(t){return new g(this.X+t,this.Y)}}(S=u||(u={}))[S.InvalidValue=0]="InvalidValue",S[S.Left=1]="Left",S[S.Center=2]="Center",S[S.Right=3]="Right";var c=u;class m{constructor(){this.ParentAlignment=c.InvalidValue,this.ParentChildSpacing=20,this.ParentConnectorShield=50,this.SiblingSpacing=20,this.ChildConnectorHookLength=5}get SupportsAssistants(){return this.GetSupportsAssistants()}}class f{static MinMax(){return new f(Number.MAX_VALUE,Number.MIN_VALUE)}constructor(t,e){this.From=t,this.To=e}static add(t,e){return new f(Math.min(t.From,e.From),Math.max(t.To,e.To))}}class p{get BottomRight(){return new g(this.TopLeft.X+this.Size.Width,this.TopLeft.Y+this.Size.Height)}get Left(){return this.TopLeft.X}get Right(){return this.TopLeft.X+this.Size.Width}get CenterH(){return this.TopLeft.X+this.Size.Width/2}get CenterV(){return this.TopLeft.Y+this.Size.Height/2}get Top(){return this.TopLeft.Y}get Bottom(){return this.TopLeft.Y+this.Size.Height}constructor(t,e,i,o){if(i<0)throw new Error("Width out of range");if(o<0)throw new Error("Height out of range");this.TopLeft=new g(t,e),this.Size=new r(i,o)}static from(t,e=new g(0,0)){return new p(e.X,e.Y,t.Width,t.Height)}static add(t,e){const i=Math.min(t.Left,e.Left),o=Math.min(t.Top,e.Top),n=Math.max(t.Right,e.Right),r=Math.max(t.Bottom,e.Bottom);return new p(i,o,n-i,r-o)}MoveH(t){return p.from(this.Size,new g(this.Left+t,this.Top))}}class C{constructor(){this._effectiveLayoutStrategy=null,this.IsHidden=!1,this.Connector=null,this.NumberOfSiblings=0,this.NumberOfSiblingRows=0,this.NumberOfSiblingColumns=0,this.Size=new r(0,0),this.TopLeft=new g(0,0),this.BranchExterior=new p(0,0,0,0),this.SiblingsRowV=new f(0,0)}set EffectiveLayoutStrategy(t){this._effectiveLayoutStrategy=t}get RequireLayoutStrategy(){if(null==this._effectiveLayoutStrategy)throw new Error("EffectiveLayoutStrategy is not set");return this._effectiveLayoutStrategy}get Left(){if(null==this.TopLeft)throw Error("TopLeft is null");return this.TopLeft.X}get Right(){if(null==this.TopLeft)throw Error("TopLeft is null");if(null==this.Size)throw Error("Size is null");return this.TopLeft.X+this.Size.Width}get Top(){if(null==this.TopLeft)throw Error("TopLeft is null");if(null==this.Size)throw Error("Size is null");return this.TopLeft.Y}get Bottom(){if(null==this.TopLeft)throw Error("TopLeft is null");if(null==this.Size)throw Error("Size is null");return this.TopLeft.Y+this.Size.Height}get CenterH(){if(null==this.TopLeft)throw Error("TopLeft is null");if(null==this.Size)throw Error("Size is null");return this.TopLeft.X+this.Size.Width/2}get CenterV(){if(null==this.TopLeft)throw Error("TopLeft is null");if(null==this.Size)throw Error("Size is null");return this.TopLeft.Y+this.Size.Height/2}}class b{constructor(t){this.Level=0,this.Children=[],this.AssistantsRoot=null,this.ParentNode=null,this.Element=t,this.State=new C}get ChildCount(){var t;return(null==(t=this.Children)?void 0:t.length)||0}get IsAssistantRoot(){var t;return(null==(t=this.ParentNode)?void 0:t.AssistantsRoot)==this}AddAssistantChild(t){return null==this.AssistantsRoot&&(this.AssistantsRoot=new b(s.Special(s.None,this.Element.Id,!0)),this.AssistantsRoot.ParentNode=this,this.AssistantsRoot.Level=this.AssistantsRoot.Level+1),this.AssistantsRoot.AddRegularChild(t),this}AddRegularChild(t){return this.InsertRegularChild(this.ChildCount,t)}AddRegularChildBox(t){return this.InsertRegularChildBoxByIndex(this.ChildCount,t)}InsertRegularChildBox(t){return this.InsertRegularChildBoxByIndex(this.ChildCount,t)}InsertRegularChildBoxByIndex(t,e){return this.InsertRegularChild(t,new b(e))}InsertRegularChild(t,e){return null==this.Children&&(this.Children=[]),this.Children.splice(t,0,e),e.ParentNode=this,e.Level=this.Level+1,this}IterateChildFirst(t){if(null!=this.AssistantsRoot&&!this.AssistantsRoot.IterateChildFirst(t))return!1;if(null!=this.Children)for(const e of this.Children)if(!e.IterateChildFirst(t))return!1;return t(this)}IterateParentFirst(t,e){var i;if(!t(this))return e&&e(this),!1;if(null==(i=this.AssistantsRoot)||i.IterateParentFirst(t,e),null!=this.Children)for(const i of this.Children)i.IterateParentFirst(t,e);return e&&e(this),!0}SuppressAssistants(){if(null!=this.AssistantsRoot){for(const t of this.AssistantsRoot.Children)this.AddRegularChild(t);this.AssistantsRoot=null}}}class w{constructor(){this.Depth=0,this.Root=null,this.Nodes=new Map}IterateChildFirst(t){if(null==this.Root)throw Error("Root is null");return this.Root.IterateChildFirst(t)}IterateParentFirst(t,e){if(null==this.Root)throw Error("Root is null");this.Root.IterateParentFirst(t,e)}UpdateHierarchyStats(){this.Depth=0,this.IterateParentFirst(t=>(null!=t.ParentNode?(t.Level=t.ParentNode.Level,t.ParentNode.IsAssistantRoot||(t.Level=t.Level+1),this.Depth=Math.max(1+t.Level,this.Depth)):(t.Level=0,this.Depth=1),!0))}static Build(t){const e=new w;let i;for(i of t.Diagram.Boxes.BoxesById.values()){const t=new b(i);e.Nodes.set(i.Id,t)}for(const t of e.Nodes.values()){const i=t.Element.ParentId,o=e.Nodes.get(i);if(o)t.Element.IsAssistant&&o.Element.ParentId!=s.None?o.AddAssistantChild(t):o.AddRegularChild(t);else{if(null!=e.Root)throw new Error("InvalidOperationException: More then one root found: "+t.Element.Id);e.Root=t}}return e}}const R=t=>t[t.length-1];class B{static ComputeBranchVisualBoundingRect(t){let e=new p(0,0,0,0),i=!1;if(null==t.Root)throw Error("Root is null");return t.Root.IterateParentFirst(t=>{var o=t.Element;if(!t.State.IsHidden&&!o.IsSpecial){if(null==t.State.Size)throw Error("Size is null");if(null==t.State.TopLeft)throw Error("TopLeft is null");i?e=p.add(e,p.from(t.State.Size,t.State.TopLeft)):(i=!0,e=p.from(t.State.Size,t.State.TopLeft))}return!o.IsCollapsed}),e}static Apply(t){var e,i;if(t.Diagram.Boxes&&null==t.Diagram.Boxes.SystemRoot)throw new Error("SystemRoot is not initialized on the box container");t.CurrentOperation=d.Preparing;var o=w.Build(t);if(t.Diagram.VisualTree=o,null==o.Root||t.Diagram.Boxes&&o.Root.Element.Id!=(null==(e=t.Diagram.Boxes.SystemRoot)?void 0:e.Id))throw new Error("SystemRoot is not on the top of the visual tree");if(o.UpdateHierarchyStats(),t.AttachVisualTree(o),o.IterateParentFirst(t=>(t.State.IsHidden=null!=t.ParentNode&&(t.ParentNode.State.IsHidden||t.ParentNode.Element.IsCollapsed),!0)),t.CurrentOperation=d.PreprocessVisualTree,null!=t.BoxSizeFunc)for(const e of[...null==(i=t.Diagram.Boxes)?void 0:i.BoxesById.values()].filter(t=>t.IsDataBound))e.Size=t.BoxSizeFunc(e.DataId);for(const e of t.Diagram.Boxes.BoxesById.values())this.AssertBoxSize(e);o.IterateParentFirst(t=>(B.MoveTo(t.State,0,0),t.State.Size=t.Element.Size,t.State.BranchExterior=p.from(t.Element.Size,new g(0,0)),!0)),this.PreprocessVisualTree(t,o),o.UpdateHierarchyStats(),t.CurrentOperation=d.VerticalLayout,this.VerticalLayout(t,o.Root),t.CurrentOperation=d.HorizontalLayout,this.HorizontalLayout(t,o.Root),t.CurrentOperation=d.ConnectorsLayout,this.RouteConnectors(t,o),t.CurrentOperation=d.Completed}static AssertBoxSize(t){if(!(t.Size.Width>=0&&t.Size.Width<=1e9&&t.Size.Height>=0&&t.Size.Width<=1e9))throw new Error(`Box ${t.Id} has invalid size: ${t.Size.Width}x${t.Size.Height}`)}static PreprocessVisualTree(t,e){const i=t.Diagram.LayoutSettings.RequireDefaultLayoutStrategy(),o=t.Diagram.LayoutSettings.RequireDefaultAssistantLayoutStrategy(),n=[];n.push(i);const r=[];r.push(o),e.IterateParentFirst(e=>{var i;if(e.State.IsHidden)return!1;let o=null;if(null!=t.LayoutOptimizerFunc){var s=t.LayoutOptimizerFunc(e);s&&(o=t.Diagram.LayoutSettings.LayoutStrategies.get(s))}if(e.IsAssistantRoot){if(null==o&&(o=null!=(null==(i=e.ParentNode)?void 0:i.Element.AssistantLayoutStrategyId)?t.Diagram.LayoutSettings.LayoutStrategies.get(e.ParentNode.Element.AssistantLayoutStrategyId):R(r)),null==o)throw Error("Strategy is null. Maybe it allows null?");r.push(o)}else{if(null==o&&(o=null!=e.Element.LayoutStrategyId?t.Diagram.LayoutSettings.LayoutStrategies.get(e.Element.LayoutStrategyId):R(n)),null==o)throw Error("Strategy is null. Maybe it allows null?");n.push(o),o.SupportsAssistants||e.SuppressAssistants()}return e.State.EffectiveLayoutStrategy=o,e.State.RequireLayoutStrategy.PreProcessThisNode(t,e),!e.Element.IsCollapsed&&e.ChildCount>0||null!=e.AssistantsRoot},t=>{t.State.IsHidden||(t.IsAssistantRoot?r.pop():n.pop())})}static HorizontalLayout(t,e){if(e.State.IsHidden)throw new Error(`Branch root ${e.Element.Id} does not affect layout`);let i=t.PushLayoutLevel(e);try{(0==e.Level||(e.State.NumberOfSiblings>0||null!=e.AssistantsRoot)&&!e.Element.IsCollapsed)&&e.State.RequireLayoutStrategy.ApplyHorizontalLayout(t,i)}finally{t.PopLayoutLevel()}}static VerticalLayout(t,e){if(e.State.IsHidden)throw new Error(`Branch root ${e.Element.Id} does not affect layout`);var i=t.PushLayoutLevel(e);try{(0==e.Level||(e.State.NumberOfSiblings>0||null!=e.AssistantsRoot)&&!e.Element.IsCollapsed)&&e.State.RequireLayoutStrategy.ApplyVerticalLayout(t,i)}finally{t.PopLayoutLevel()}}static RouteConnectors(t,e){e.IterateParentFirst(e=>!(e.Element.IsCollapsed||0==e.State.NumberOfSiblings&&null==e.AssistantsRoot)&&(0==e.Level||!(e.Element.IsSpecial&&!e.IsAssistantRoot)&&(e.State.RequireLayoutStrategy.RouteConnectors(t,e),!0)))}static MoveChildrenOnly(t,e,i){const o=e.BranchRoot.Children;if(null==o||0==o.length)throw new Error("Should never be invoked when children not set");const n=t=>{if(!t.State.IsHidden)try{t.State.TopLeft=t.State.TopLeft.MoveH(i),t.State.BranchExterior=t.State.BranchExterior.MoveH(i)}catch(t){}return!0};for(const t of o)t.IterateChildFirst(n);e.Boundary.ReloadFromBranch(e.BranchRoot),e.BranchRoot.State.BranchExterior=e.Boundary.BoundingRect}static MoveOneChild(t,e,i){e.IterateChildFirst(t=>(t.State.IsHidden||(t.State.TopLeft=t.State.TopLeft.MoveH(i),t.State.BranchExterior=t.State.BranchExterior.MoveH(i)),!0))}static MoveBranch(t,e,i){this.MoveOneChild(t,e.BranchRoot,i),e.Boundary.ReloadFromBranch(e.BranchRoot),e.BranchRoot.State.BranchExterior=e.Boundary.BoundingRect}static AlignHorizontalCenters(t,e,i){let o=Number.MIN_VALUE;for(const t of i){var n=t.State.CenterH;n>o&&(o=n)}let r=Number.MAX_VALUE,s=Number.MIN_VALUE;for(const e of i){const i=e.State.CenterH;if(i!==o){const n=o-i;this.MoveOneChild(t,e,n)}r=Math.min(r,e.State.BranchExterior.Left),s=Math.max(s,e.State.BranchExterior.Right)}return e.Boundary.ReloadFromBranch(e.BranchRoot),new f(r,s)}static CopyExteriorFrom(t,e){t.TopLeft=e.TopLeft,t.Size=e.Size,t.BranchExterior=e.BranchExterior,t.SiblingsRowV=e.SiblingsRowV}static IsMinValue(t){return t<=Number.MIN_VALUE+Number.EPSILON}static IsMaxValue(t){return t>=Number.MAX_VALUE-Number.EPSILON}static IsZero(t){return t<=Number.EPSILON&&t>=-Number.EPSILON}static IsEqual(t,e){return Math.abs(t-e)<=Number.EPSILON}static MoveTo(t,e,i){t.TopLeft=new g(e,i)}static AdjustSpacer(t,e,i,o,n){t.TopLeft=new g(e,i),t.Size=new r(o,n),t.BranchExterior=new p(e,i,o,n)}}class L{constructor(t,e){this.From=t,this.To=e}}class y{constructor(t){if(0==t.length)throw new Error("Need at least one segment");this.Segments=t}}class x extends m{constructor(){super(...arguments),this.GetSupportsAssistants=()=>!0}PreProcessThisNode(t,e){if(e.ChildCount>0&&(e.State.NumberOfSiblings=e.Element.IsCollapsed?0:e.ChildCount,!e.Element.IsCollapsed)){const t=s.Special(s.None,e.Element.Id,!1);e.AddRegularChildBox(t);const i=s.Special(s.None,e.Element.Id,!1);e.AddRegularChildBox(i)}}ApplyVerticalLayout(t,e){let i=e.BranchRoot;if(0==i.Level&&(i.State.SiblingsRowV=new f(i.State.Top,i.State.Bottom)),null!=i.AssistantsRoot&&(B.CopyExteriorFrom(i.AssistantsRoot.State,i.State),B.VerticalLayout(t,i.AssistantsRoot)),0==i.State.NumberOfSiblings)return;let o,n=f.MinMax();if(null==i.AssistantsRoot){if(null==i.State.SiblingsRowV)throw Error("SiblingsRowV is null");o=i.State.SiblingsRowV.To+this.ParentChildSpacing}else o=i.State.BranchExterior.Bottom+this.ParentChildSpacing;for(let t=0;t<i.State.NumberOfSiblings;t++){let e=i.Children[t],r=e.State;if(B.MoveTo(e.State,0,o),null==e.State.Size)throw Error("Size is null");if(e.State.BranchExterior=p.from(e.State.Size,e.State.TopLeft),null==r.Size)throw Error("Size is null");n=f.add(n,new f(o,o+r.Size.Height))}n=new f(n.From,n.To);for(let e=0;e<i.State.NumberOfSiblings;e++){let o=i.Children[e];o.State.SiblingsRowV=n,B.VerticalLayout(t,o)}}ApplyHorizontalLayout(t,e){let i=e.BranchRoot;null!=i.AssistantsRoot&&B.HorizontalLayout(t,i.AssistantsRoot);for(let e=0;e<i.State.NumberOfSiblings;e++){let o=i.Children[e];B.HorizontalLayout(t,o)}if(i.Level>0&&i.ChildCount>0){let o=i.State,n=i.Children[0].State.CenterH,r=i.Children[i.State.NumberOfSiblings-1].State.CenterH,s=1==i.State.NumberOfSiblings||this.ParentAlignment==c.Center?n+(r-n)/2:this.ParentAlignment==c.Left?n+this.ChildConnectorHookLength:r-this.ChildConnectorHookLength,a=o.CenterH,l=a-s;B.MoveChildrenOnly(t,e,l);let h=i.Children[i.State.NumberOfSiblings];if(null==i.Children[0].State.SiblingsRowV)throw Error("SiblingsRowV is null");B.AdjustSpacer(h.State,a-this.ParentConnectorShield/2,o.Bottom,this.ParentConnectorShield,i.Children[0].State.SiblingsRowV.From-o.Bottom),t.MergeSpacer(h);let u=i.Children[0].State,S=i.Children[i.State.NumberOfSiblings+1];if(null==u.SiblingsRowV)throw Error("SiblingsRowV is null");B.AdjustSpacer(S.State,u.Left,u.SiblingsRowV.From-this.ParentChildSpacing,i.Children[i.State.NumberOfSiblings-1].State.Right-u.Left,this.ParentChildSpacing),t.MergeSpacer(S)}}RouteConnectors(t,e){let i=e.State.NumberOfSiblings,o=0==i?0:1==i?1:2+i;if(0==o)return void(e.State.Connector=null);let n=[],r=e.State,s=r.CenterH;if(null==e.Children)throw new Error("State is present, but children not set");if(1==o)n[0]=new L(new g(s,r.Bottom),new g(s,e.Children[0].State.Top));else{if(null==e.Children[0].State.SiblingsRowV)throw Error("SiblingsRowV is null");let t=e.Children[0].State.SiblingsRowV.From-r.Bottom;n[0]=new L(new g(s,r.Bottom),new g(s,r.Bottom+t-this.ChildConnectorHookLength));for(let t=0;t<i;t++){let i=e.Children[t].State,o=i.CenterH;n[1+t]=new L(new g(o,i.Top),new g(o,i.Top-this.ChildConnectorHookLength))}n[o-1]=new L(new g(n[1].To.X,n[1].To.Y),new g(n[o-2].To.X,n[1].To.Y))}e.State.Connector=new y(n)}}var I,N;(N=I||(I={}))[N.InvalidValue=0]="InvalidValue",N[N.SingleRowHorizontal=1]="SingleRowHorizontal",N[N.SingleColumnVertical=2]="SingleColumnVertical";var O=I;class A extends m{constructor(){super(),this.GetSupportsAssistants=()=>!1,this.Orientation=O.SingleRowHorizontal,this.ParentAlignment=c.InvalidValue,this.ChildConnectorHookLength=0,this.ParentConnectorShield=0,this.SiblingSpacing=5}PreProcessThisNode(t,e){if(e.State.NumberOfSiblings=e.Element.IsCollapsed?0:e.ChildCount,e.State.NumberOfSiblings>0&&this.Orientation!=O.SingleRowHorizontal&&this.Orientation!=O.SingleColumnVertical)throw new Error("InvalidOperationException: Unsupported value for orientation: "+this.Orientation)}ApplyVerticalLayout(t,e){let i=e.BranchRoot;if(0==i.Level&&(i.State.SiblingsRowV=new f(i.State.Top,i.State.Bottom)),0==i.State.NumberOfSiblings)return;let o=f.MinMax();if(this.Orientation==O.SingleRowHorizontal){let e=null==i.AssistantsRoot?i.State.SiblingsRowV.To+this.ParentChildSpacing:i.State.BranchExterior.Bottom+this.ParentChildSpacing;for(let t=0;t<i.State.NumberOfSiblings;t++){let n=i.Children[t],r=n.State;B.MoveTo(n.State,0,e),n.State.BranchExterior=p.from(n.State.Size,n.State.TopLeft),o=f.add(o,new f(e,e+r.Size.Height))}o=new f(o.From,o.To);for(let e=0;e<i.State.NumberOfSiblings;e++){let n=i.Children[e];n.State.SiblingsRowV=o,B.VerticalLayout(t,n)}}else if(this.Orientation==O.SingleColumnVertical){let e=new f(i.State.SiblingsRowV.From,i.State.SiblingsRowV.To);for(let o=0;o<i.State.NumberOfSiblings;o++){let n=i.Children[o],r=n.State,s=e.To+(0==o?this.ParentChildSpacing:this.SiblingSpacing);B.MoveTo(n.State,r.Left,s),n.State.BranchExterior=p.from(n.State.Size,n.State.TopLeft);let a=new f(s,s+r.Size.Height);n=i.Children[o],n.State.SiblingsRowV=a,B.VerticalLayout(t,n);let l=n.State.BranchExterior.Bottom;e=new f(a.From,Math.max(l,a.To))}}}ApplyHorizontalLayout(t,e){let i=e.BranchRoot;for(let e of i.Children)B.HorizontalLayout(t,e);if(i.ChildCount>0)if(this.Orientation==O.SingleRowHorizontal){let o=i.Children[i.State.NumberOfSiblings-1].State.Right-i.Children[0].State.Left;i.State.Size=new r(Math.max(i.State.Size.Width,o),i.State.Size.Height);let n=(i.Children[0].State.Left+i.Children[i.ChildCount-1].State.Right)/2,s=i.State.CenterH-n;B.MoveChildrenOnly(t,e,s)}else if(this.Orientation==O.SingleColumnVertical){B.AlignHorizontalCenters(t,e,i.Children);let o=i.Children[0].State.CenterH,n=i.State.CenterH-o;B.MoveChildrenOnly(t,e,n)}}RouteConnectors(t,e){}}class E{constructor(t,e){this.Group=0,this.FromIndex=0,this.Count=0,this.MaxOnLeft=0,this._numberOfSiblings=t,this._numberOfGroups=e}CountInGroup(){let t=2*this._numberOfGroups,e=0,i=2*this.Group+2,o=0;for(;;){let n=o>=this._numberOfSiblings-t?this._numberOfSiblings-o:t;if(!(n>=i)){i--,n>=i&&e++;break}e+=2,o+=t}return e}NextGroup(){return this.FromIndex=this.FromIndex+this.Count,this.FromIndex>0&&this.Group++,this.Count=this.CountInGroup(),this.MaxOnLeft=Math.floor(this.Count/2)+this.Count%2,0!=this.Count}}class v extends b{constructor(t){super(t)}Prepare(t){null==this.Children?this.Children=[]:this.Children.length=0}AddChildView(t){this.Children.push(t)}}class T extends m{constructor(t){super(),this.GetSupportsAssistants=()=>!1,this.Iterator=new E(t.State.NumberOfSiblings,t.State.NumberOfSiblingColumns),this.RealRoot=t,this.SpecialRoot=new v(s.Special(s.None,t.Element.Id,!0)),this.SpecialRoot.Level=this.RealRoot.Level,this.SpecialRoot.ParentNode=this.RealRoot,this.SpecialRoot.State.EffectiveLayoutStrategy=this;let e=t.State.RequireLayoutStrategy;this.SiblingSpacing=e.SiblingSpacing,this.ParentConnectorShield=e.ParentConnectorShield,this.ParentChildSpacing=e.ParentChildSpacing,this.ParentAlignment=e.ParentAlignment,this.ChildConnectorHookLength=e.ChildConnectorHookLength}NextGroup(){if(!this.Iterator.NextGroup())return!1;this.SpecialRoot.State.NumberOfSiblings=this.Iterator.Count,this.SpecialRoot.Prepare(2*this.RealRoot.State.NumberOfSiblingRows);for(let t=0;t<this.Iterator.Count;t++)this.SpecialRoot.AddChildView(this.RealRoot.Children[this.Iterator.FromIndex+t]);let t=this.RealRoot.Children[this.RealRoot.State.NumberOfSiblings+1+this.Iterator.Group];return this.SpecialRoot.AddChildView(t),B.CopyExteriorFrom(this.SpecialRoot.State,this.RealRoot.State),!0}PreProcessThisNode(t,e){throw new Error("NotSupportedException")}ApplyVerticalLayout(t,e){var i,o;if(null==this.SpecialRoot.State.SiblingsRowV)throw Error("SiblingsRowV is null");let n=null!=(o=null==(i=this.RealRoot.AssistantsRoot)?void 0:i.State.BranchExterior.Bottom)?o:this.SpecialRoot.State.SiblingsRowV.To;for(let e=0;e<this.Iterator.MaxOnLeft;e++){let i=0==e?this.ParentChildSpacing:this.SiblingSpacing,o=this.SpecialRoot.Children[e],r=o.State;B.MoveTo(r,r.Left,n+i);let s=new f(r.Top,r.Bottom),a=e+this.Iterator.MaxOnLeft;if(null==r.Size)throw Error("Size is null");if(a<this.Iterator.Count){let e=this.SpecialRoot.Children[a],o=e.State;if(B.MoveTo(o,o.Left,n+i),null==o.Size)throw Error("Size is null");o.Bottom>r.Bottom?B.MoveTo(r,r.Left,o.CenterV-r.Size.Height/2):o.Bottom<r.Bottom&&B.MoveTo(o,o.Left,r.CenterV-o.Size.Height/2),o.BranchExterior=p.from(o.Size,o.TopLeft),s=f.add(s,new f(o.Top,o.Bottom)),o.SiblingsRowV=s,B.VerticalLayout(t,e),n=o.BranchExterior.Bottom}r.BranchExterior=p.from(r.Size,r.TopLeft),r.SiblingsRowV=s,B.VerticalLayout(t,o),n=Math.max(n,r.BranchExterior.Bottom)}}ApplyHorizontalLayout(t,e){if(e.BranchRoot!=this.SpecialRoot)throw new Error("InvalidOperationException: Wrong root node received");let i=!0,o=0;for(let n=0;n<this.Iterator.Count;n++){let r=this.SpecialRoot.Children[n];if(B.HorizontalLayout(t,r),++o==this.Iterator.MaxOnLeft&&i){B.AlignHorizontalCenters(t,e,this.EnumerateSiblings(0,this.Iterator.MaxOnLeft)),i=!1,o=0;let s=Number.MIN_VALUE;for(let t=0;t<n;t++)s=Math.max(s,this.SpecialRoot.Children[t].State.BranchExterior.Right);s=Math.max(s,r.State.Right);let a=this.SpecialRoot.Children[this.SpecialRoot.State.NumberOfSiblings];if(null==this.SpecialRoot.Children[0].State.SiblingsRowV)throw Error("SiblingsRowV is null");if(null==r.State.SiblingsRowV)throw Error("SiblingsRowV is null");B.AdjustSpacer(a.State,s,this.SpecialRoot.Children[0].State.SiblingsRowV.From,this.SiblingSpacing,r.State.SiblingsRowV.To-this.SpecialRoot.Children[0].State.SiblingsRowV.From),e.Boundary.MergeFromNode(a)}}B.AlignHorizontalCenters(t,e,this.EnumerateSiblings(this.Iterator.MaxOnLeft,this.Iterator.Count))}EnumerateSiblings(t,e){const i=[];for(let o=t;o<e;o++)i.push(this.SpecialRoot.Children[o]);return i}RouteConnectors(t,e){throw new Error}}class M extends x{constructor(){super(...arguments),this.MaxGroups=4,this.GetSupportsAssistants=()=>!0}PreProcessThisNode(t,e){if(this.MaxGroups<=0)throw new Error("MaxGroups must be a positive value");if(e.ChildCount<=2*this.MaxGroups)super.PreProcessThisNode(t,e);else if(e.State.NumberOfSiblings=e.ChildCount,e.State.NumberOfSiblings>0){e.State.NumberOfSiblingColumns=this.MaxGroups,e.State.NumberOfSiblingRows=Math.floor(e.State.NumberOfSiblings/(2*this.MaxGroups)),e.State.NumberOfSiblings%(2*this.MaxGroups)!=0&&e.State.NumberOfSiblingRows++;let t=s.Special(s.None,e.Element.Id,!1);e.AddRegularChildBox(t);for(let t=0;t<e.State.NumberOfSiblingColumns;t++){let t=s.Special(s.None,e.Element.Id,!1);e.AddRegularChildBox(t)}if(e.State.NumberOfSiblingColumns>1){let t=s.Special(s.None,e.Element.Id,!1);e.AddRegularChildBox(t)}}}ApplyVerticalLayout(t,e){let i=e.BranchRoot;if(i.State.NumberOfSiblings<=2*this.MaxGroups)return void super.ApplyVerticalLayout(t,e);0==i.Level&&(i.State.SiblingsRowV=new f(i.State.Top,i.State.Bottom)),null!=i.AssistantsRoot&&(B.CopyExteriorFrom(i.AssistantsRoot.State,i.State),B.VerticalLayout(t,i.AssistantsRoot));let o=new T(i);for(;o.NextGroup();)B.VerticalLayout(t,o.SpecialRoot)}ApplyHorizontalLayout(t,e){let i=e.BranchRoot;if(i.State.NumberOfSiblings<=2*this.MaxGroups)return void super.ApplyHorizontalLayout(t,e);0==i.Level&&(i.State.SiblingsRowV=new f(i.State.Top,i.State.Bottom)),null!=i.AssistantsRoot&&B.HorizontalLayout(t,i.AssistantsRoot);let o=new T(i);for(;o.NextGroup();)B.HorizontalLayout(t,o.SpecialRoot);let n=i.State;if(i.Level>0){let o=0;if(i.State.NumberOfSiblingColumns>1){let t=i.Children[i.State.NumberOfSiblings+1].State.CenterH,e=i.Children[i.State.NumberOfSiblings+i.State.NumberOfSiblingColumns].State.CenterH,r=1==i.State.NumberOfSiblings||this.ParentAlignment==c.Center?t+(e-t)/2:this.ParentAlignment==c.Left?t+this.ChildConnectorHookLength:e-this.ChildConnectorHookLength;o=n.CenterH-r}else{let t=i.Children[1+i.State.NumberOfSiblings].State.CenterH;o=n.CenterH-t}B.MoveChildrenOnly(t,e,o)}if(i.Level>0){if(null==i.Children[0].State.SiblingsRowV)throw Error("SiblingsRowV is null");let e=i.State.NumberOfSiblings,o=i.Children[e];if(B.AdjustSpacer(o.State,n.CenterH-this.ParentConnectorShield/2,n.Bottom,this.ParentConnectorShield,i.Children[0].State.SiblingsRowV.From-n.Bottom),t.MergeSpacer(o),e++,e+=i.State.NumberOfSiblingColumns,i.State.NumberOfSiblingColumns>1){let o=i.Children[e],n=i.Children[i.State.NumberOfSiblings+1].State.TopLeft,r=i.Children[e-1].State.Right;B.AdjustSpacer(o.State,n.X,n.Y-this.ParentChildSpacing,r-n.X,this.ParentChildSpacing),t.MergeSpacer(o)}}}RouteConnectors(t,e){if(e.State.NumberOfSiblings<=2*this.MaxGroups)return void super.RouteConnectors(t,e);e.State.NumberOfSiblings,e.State.NumberOfSiblingColumns;e.State.NumberOfSiblingColumns;let i=[],o=e.State,n=o.CenterH,r=0;if(null==e.Children[0].State.SiblingsRowV)throw Error("SiblingsRowV is null");let s=e.Children[0].State.SiblingsRowV.From-o.Bottom;i[r++]=new L(new g(n,o.Bottom),new g(n,o.Bottom+s-this.ChildConnectorHookLength));let a=new E(e.State.NumberOfSiblings,e.State.NumberOfSiblingColumns);for(;a.NextGroup();){let t=e.Children[1+e.State.NumberOfSiblings+a.Group].State,o=t.CenterH,n=!0,s=0;for(let l=a.FromIndex;l<a.FromIndex+a.Count;l++){let h=n?e.Children[l].State.Right:e.Children[l].State.Left,u=e.Children[l].State.CenterV;i[r++]=new L(new g(o,u),new g(h,u)),++s==a.MaxOnLeft&&(s=0,n&&(i[1+e.State.NumberOfSiblings+a.Group]=new L(new g(t.CenterH,t.Top-this.ChildConnectorHookLength),new g(t.CenterH,e.Children[l].State.CenterV))),n=!n)}}if(r+=e.State.NumberOfSiblingColumns,e.State.NumberOfSiblingColumns>1){let t=e.Children[1+e.State.NumberOfSiblings].State,o=e.Children[1+e.State.NumberOfSiblings+e.State.NumberOfSiblingColumns-1].State;i[r]=new L(new g(t.CenterH,t.Top-this.ChildConnectorHookLength),new g(o.CenterH,o.Top-this.ChildConnectorHookLength))}e.State.Connector=new y(i)}}class P extends m{constructor(){super(...arguments),this.GetSupportsAssistants=()=>!0}PreProcessThisNode(t,e){if(this.ParentAlignment!=c.Left&&this.ParentAlignment!=c.Right)throw new Error("InvalidOperationException: Unsupported value for ParentAlignment");if(e.State.NumberOfSiblings=e.Element.IsCollapsed?0:e.ChildCount,e.State.NumberOfSiblings>0&&e.Level>0){e.State.NumberOfSiblingColumns=1,e.State.NumberOfSiblingRows=e.ChildCount;let t=s.Special(s.None,e.Element.Id,!1);e.AddRegularChildBox(t)}}ApplyVerticalLayout(t,e){let i=e.BranchRoot;0==i.Level&&(i.State.SiblingsRowV=new f(i.State.Top,i.State.Bottom)),null!=i.AssistantsRoot&&(B.CopyExteriorFrom(i.AssistantsRoot.State,i.State),B.VerticalLayout(t,i.AssistantsRoot));let o=new f(i.State.SiblingsRowV.From,null==i.AssistantsRoot?i.State.SiblingsRowV.To:i.State.BranchExterior.Bottom);for(let e=0;e<i.State.NumberOfSiblings;e++){let n=i.Children[e],r=n.State,s=o.To+(0==e?this.ParentChildSpacing:this.SiblingSpacing);B.MoveTo(n.State,r.Left,s),n.State.BranchExterior=p.from(n.State.Size,n.State.TopLeft);let a=new f(s,s+r.Size.Height);n=i.Children[e],n.State.SiblingsRowV=a,B.VerticalLayout(t,n);let l=n.State.BranchExterior.Bottom;o=new f(a.From,Math.max(l,a.To))}}ApplyHorizontalLayout(t,e){let i=e.BranchRoot,o=i.State;null!=i.AssistantsRoot&&B.HorizontalLayout(t,i.AssistantsRoot);for(let e=0;e<o.NumberOfSiblings;e++){let o=i.Children[e];B.HorizontalLayout(t,o)}let n=B.AlignHorizontalCenters(t,e,this.EnumerateColumn(i));if(i.Level>0&&i.ChildCount>0){let o,r=i.State;if(this.ParentAlignment==c.Left){o=r.CenterH+this.ParentConnectorShield/2-n.From}else{if(this.ParentAlignment!=c.Right)throw new Error("InvalidOperationException: Invalid ParentAlignment setting");o=r.CenterH-this.ParentConnectorShield/2-n.To}B.MoveChildrenOnly(t,e,o);let s=i.Level>0?i.Children[i.ChildCount-1]:null;if(null!=s){let e=i.State.Bottom,o=i.Children[i.ChildCount-2].State.Bottom;B.AdjustSpacer(s.State,r.CenterH-this.ParentConnectorShield/2,e,this.ParentConnectorShield,o-e),t.MergeSpacer(s)}}}EnumerateColumn(t){const e=[];for(let i=0;i<t.State.NumberOfSiblings;i++)e.push(t.Children[i]);return e}RouteConnectors(t,e){if(0==e.ChildCount)return;let i=1+e.State.NumberOfSiblings,o=Array(i),n=e.State,r=n.CenterH,s=e.Children[e.State.NumberOfSiblings-1].State.CenterV-e.State.Bottom;o[0]=new L(new g(r,n.Bottom),new g(r,n.Bottom+s));for(let t=0;t<e.State.NumberOfSiblings;t++){let i=e.Children[t].State,n=this.ParentAlignment==c.Left?i.Left:i.Right;o[1+t]=new L(new g(r,i.CenterV),new g(n,i.CenterV))}e.State.Connector=new y(o)}}class V{constructor(){this.Items=new Map,this.GetParentKeyFunc=t=>this.GetParentKey(t),this.GetDataItemFunc=t=>this.GetDataItem(t)}GetParentKey(t){var e;return(null==(e=this.Items.get(t))?void 0:e.ParentId)||null}GetDataItem(t){const e=this.Items.get(t);if(!e)throw Error("Could not find itemId");return e}get AllDataItemIds(){return[...this.Items.keys()].sort()}}class z{constructor(t){}Next(t){return Math.floor(Math.random()*t)}}class H{GenerateDataItems(t,e,i){for(let o of this.GenerateRandomDataItems(e,i))t.Items.set(o.Id,o)}GenerateRandomDataItems(t,e){if(t<0)throw new Error("ArgumentOutOfRangeException: "+t+" - Count must be zero or positive");let i=new z(0),o=[];for(let e=0;e<t;e++)o.push({Id:e.toString(),Date1:new Date,ParentId:null,String1:null,String2:null,IsAssistant:!1});let n=1,r=1;for(;n<t;){let e=15+r+i.Next(2*r);for(let s=n;s<n+e&&s<t;s++){let t=n-1-i.Next(r);o[s].ParentId=o[t].Id}n+=e,r=e}for(let t=0;t<o.length/2;t++){let t=i.Next(o.length),e=i.Next(o.length),n=o[t];o[t]=o[e],o[e]=n}if(e>0){let t=Math.min(o.length,Math.round(Math.ceil(o.length*e/100)));for(let e=0;e<t;e++)o[i.Next(o.length)].IsAssistant=!0}return o}static GenerateBoxSizes(t){let e=new z(0);for(let i of t.BoxesById.values())i.IsSpecial||(i.Size=new r(50+e.Next(50),50+e.Next(50)))}}class F{constructor(t){this.State=t,this.CurrentOperation=t.CurrentOperation}}class D{constructor(t,e,i,o){this.Node=t,this.X=e,this.Top=i,this.Bottom=o}ChangeTop(t){return new D(this.Node,this.X,t,this.Bottom)}ChangeBottom(t){return new D(this.Node,this.X,this.Top,t)}ChangeOwner(t,e){return new D(t,e,this.Top,this.Bottom)}ChangeX(t){return new D(this.Node,t,this.Top,this.Bottom)}}class _{constructor(t=!0){this._spacerMerger=null,this._boundingRect=null,this.Left=[],this.Right=[],t&&(this._spacerMerger=new _(!1))}get BoundingRect(){if(null==this._boundingRect)throw Error("BoundingRect is null");return this._boundingRect}set BoundingRect(t){this._boundingRect=t}PrepareForHorizontalLayout(t){if(this.Prepare(t),!t.Element.DisableCollisionDetection){var e=t.State;this.Left.push(new D(t,e.Left,e.Top,e.Bottom)),this.Right.push(new D(t,e.Right,e.Top,e.Bottom))}}Prepare(t){this.Left.length=0,this.Right.length=0,this.BoundingRect=p.from(t.State.Size,t.State.TopLeft)}VerticalMergeFrom(t){this.BoundingRect=p.add(this.BoundingRect,t.BoundingRect)}MergeFrom(t){if(t.BoundingRect.Top>=t.BoundingRect.Bottom)throw new Error("Cannot merge boundary of height "+(t.BoundingRect.Bottom-t.BoundingRect.Top));let e="r";for(;"\0"!=e;){let o="r"==e?this.Right:this.Left,n="r"==e?t.Right:t.Left,r=0,s=0;for(;s<n.length&&r<o.length;){let t=o[r],a=n[s];if(t.Bottom<=a.Top)r++;else if(a.Bottom<=t.Top)o[r]=a,s++,this.ValidateState();else{var i="r"==e?t.X<=a.X:t.X>=a.X;B.IsEqual(t.Top,a.Top)?B.IsEqual(t.Bottom,a.Bottom)?(i&&(o[r]=a),r++,s++,this.ValidateState()):t.Bottom<a.Bottom?(i&&(o[r]=t.ChangeOwner(a.Node,a.X)),n[s]=a.ChangeTop(t.Bottom),r++,this.ValidateState()):(i&&(o[r]=t.ChangeTop(a.Bottom),o.splice(r,0,a),r++),s++,this.ValidateState()):B.IsEqual(t.Bottom,a.Bottom)?t.Top<a.Top?(i&&(o[r]=t.ChangeBottom(a.Top),o.splice(r+1,0,a),r++),r++,s++,this.ValidateState()):(i?o[r]=a:(o.splice(r,0,a.ChangeBottom(t.Top)),r++),r++,s++,this.ValidateState()):t.Top<a.Top&&t.Bottom<a.Bottom?(i&&(o[r]=t.ChangeBottom(a.Top),o.splice(r+1,0,new D(a.Node,a.X,a.Top,t.Bottom)),r++),n[s]=a.ChangeTop(t.Bottom),r++,this.ValidateState()):t.Top<a.Top&&t.Bottom>a.Bottom?(i&&(o[r]=t.ChangeBottom(a.Top),o.splice(r+1,0,a),o.splice(r+2,0,t.ChangeTop(a.Bottom)),r+=2),s++,this.ValidateState()):t.Bottom>a.Bottom?(i?(o[r]=t.ChangeTop(a.Bottom),o.splice(r,0,a)):o.splice(r,0,a.ChangeBottom(t.Top)),r++,s++,this.ValidateState()):(i?o[r]=a.ChangeBottom(t.Bottom):(o.splice(r,0,a.ChangeBottom(t.Top)),r++),n[s]=a.ChangeTop(t.Bottom),r++,this.ValidateState())}}if(r==o.length)for(;s<n.length;)o.push(n[s]),s++,this.ValidateState();e="r"==e?"l":"\0"}this.BoundingRect=p.add(this.BoundingRect,t.BoundingRect)}ValidateState(){for(var t=1;t<this.Left.length;t++)if(this.Left[t].Top==this.Left[t].Bottom||this.Left[t].Top<this.Left[t-1].Bottom||this.Left[t].Top<=this.Left[t-1].Top||this.Left[t].Bottom<=this.Left[t].Top||this.Left[t].Bottom<=this.Left[t-1].Bottom)throw new Error("State error at Left index "+t);for(t=1;t<this.Right.length;t++)if(this.Right[t].Top==this.Right[t].Bottom||this.Right[t].Top<this.Right[t-1].Bottom||this.Right[t].Top<=this.Right[t-1].Top||this.Right[t].Bottom<=this.Right[t].Top||this.Right[t].Bottom<=this.Right[t-1].Bottom)throw new Error("State error at Right index "+t)}MergeFromNode(t){if(!t.Element.DisableCollisionDetection&&t.State.Size&&!B.IsZero(t.State.Size.Height)){if(null==this._spacerMerger)throw Error("SpaceMerger is null");this._spacerMerger.PrepareForHorizontalLayout(t),this.MergeFrom(this._spacerMerger)}}ComputeOverlap(t,e,i){let o=0,n=0,r=0;for(;o<this.Right.length&&n<t.Left.length;){let l=this.Right[o],h=t.Left[n];if(l.Bottom<=h.Top)o++;else if(h.Bottom<=l.Top)n++;else{if(!l.Node.Element.DisableCollisionDetection&&!h.Node.Element.DisableCollisionDetection){var s=l.Node.Element.IsSpecial||h.Node.Element.IsSpecial?0:l.Node.Element.ParentId==h.Node.Element.ParentId?e:i,a=l.X+s-h.X;a>r&&(r=a)}l.Bottom>=h.Bottom&&n++,h.Bottom>=l.Bottom&&o++}}return r}ReloadFromBranch(t){for(var e=Number.MAX_VALUE,i=Number.MIN_VALUE,o=0;o<this.Left.length;o++){var n=this.Left[o],s=n.Node.State.Left;this.Left[o]=n.ChangeX(s),e=Math.min(e,s)}for(o=0;o<this.Right.length;o++){var a=this.Right[o],l=a.Node.State.Right;this.Right[o]=a.ChangeX(l),i=Math.max(i,l)}e=Math.min(t.State.Left,e),i=Math.max(t.State.Right,i),this.BoundingRect=p.from(new r(i-e,this.BoundingRect.Size.Height),new g(e,this.BoundingRect.Top))}}class k{constructor(t,e){this.BranchRoot=t,this.Boundary=e}}class G{constructor(t,e,i){this.Boundary=t,this.LayoutLevel=e,this.State=i}}class X{constructor(t){this._currentOperation=d.Idle,this._layoutStack=[],this._pooledBoundaries=[],this.BoxSizeFunc=null,this.LayoutOptimizerFunc=null,this.BoundaryChanged=null,this.OperationChanged=null,this.Diagram=t}get CurrentOperation(){return this._currentOperation}set CurrentOperation(t){this._currentOperation=t,this.OperationChanged&&this.OperationChanged(this,new F(this))}AttachVisualTree(t){for(;this._pooledBoundaries.length<t.Depth;)this._pooledBoundaries.push(new _)}PushLayoutLevel(t){0==this._pooledBoundaries.length&&this._pooledBoundaries.push(new _);const e=this._pooledBoundaries.pop();switch(this.CurrentOperation){case d.VerticalLayout:null==e||e.Prepare(t);break;case d.HorizontalLayout:null==e||e.PrepareForHorizontalLayout(t);break;default:throw new Error("This operation can only be invoked when performing vertical or horizontal layouts")}if(null==e)throw Error("Boundary cannot be null");var i=new k(t,e);return this._layoutStack.push(i),this.BoundaryChanged&&this.BoundaryChanged(this,new G(e,i,this)),i}MergeSpacer(t){if(this.CurrentOperation!=d.HorizontalLayout)throw new Error("Spacers can only be merged during horizontal layout");if(0==this._layoutStack.length)throw new Error("Cannot merge spacers at top nesting level");const e=R(this._layoutStack);if(null==e)throw Error("Level is null");e.Boundary.MergeFromNode(t),this.BoundaryChanged&&this.BoundaryChanged(this,new G(e.Boundary,e,this))}PopLayoutLevel(){var t,e;const i=this._layoutStack.pop();if(null==i)throw Error("innerLevel is null");if(this.BoundaryChanged&&this.BoundaryChanged(this,new G(i.Boundary,i,this)),this._layoutStack.length>0){const o=R(this._layoutStack);if(null==o)throw Error("higherLevel is null");switch(this.CurrentOperation){case d.VerticalLayout:o.Boundary.VerticalMergeFrom(i.Boundary),o.BranchRoot.State.BranchExterior=o.Boundary.BoundingRect;break;case d.HorizontalLayout:if(o.BranchRoot.AssistantsRoot!=i.BranchRoot){const t=o.BranchRoot.State.RequireLayoutStrategy,e=o.Boundary.ComputeOverlap(i.Boundary,t.SiblingSpacing,this.Diagram.LayoutSettings.BranchSpacing);e>0&&(B.MoveBranch(this,i,e),this.BoundaryChanged&&this.BoundaryChanged(this,new G(i.Boundary,i,this)))}o.Boundary.MergeFrom(i.Boundary),o.BranchRoot.State.BranchExterior=new p(o.Boundary.BoundingRect.Left,null==(t=o.BranchRoot.State.BranchExterior)?void 0:t.Top,o.Boundary.BoundingRect.Size.Width,null==(e=o.BranchRoot.State.BranchExterior)?void 0:e.Size.Height);break;default:throw new Error("This operation can only be invoked when performing vertical or horizontal layouts")}this.BoundaryChanged&&this.BoundaryChanged(this,new G(o.Boundary,o,this))}this._pooledBoundaries.push(i.Boundary)}}class Y extends x{constructor(){super(...arguments),this.MaxSiblingsPerRow=4,this.GetSupportsAssistants=()=>!0}PreProcessThisNode(t,e){if(this.MaxSiblingsPerRow<=0||this.MaxSiblingsPerRow%2!=0)throw new Error("MaxSiblingsPerRow must be a positive even value");if(e.ChildCount<=this.MaxSiblingsPerRow)super.PreProcessThisNode(t,e);else if(e.State.NumberOfSiblings=e.ChildCount,e.State.NumberOfSiblings>0){let t=e.ChildCount%this.MaxSiblingsPerRow;e.State.NumberOfSiblingColumns=1+this.MaxSiblingsPerRow,e.State.NumberOfSiblingRows=Math.floor(e.ChildCount/this.MaxSiblingsPerRow),0!=t&&e.State.NumberOfSiblingRows++,e.State.NumberOfSiblings=e.ChildCount+e.State.NumberOfSiblingRows,t>0&&t<=Math.floor(this.MaxSiblingsPerRow/2)&&e.State.NumberOfSiblings--;let i=Math.floor(this.MaxSiblingsPerRow/2);for(;i<e.State.NumberOfSiblings;){let t=s.Special(s.None,e.Element.Id,!1);e.InsertRegularChildBoxByIndex(i,t),i+=e.State.NumberOfSiblingColumns}let o=s.Special(s.None,e.Element.Id,!1);e.AddRegularChildBox(o);for(let t=0;t<e.State.NumberOfSiblingRows;t++){let t=s.Special(s.None,e.Element.Id,!1);e.AddRegularChildBox(t)}}}ApplyVerticalLayout(t,e){let i=e.BranchRoot;if(i.State.NumberOfSiblings<=this.MaxSiblingsPerRow)return void super.ApplyVerticalLayout(t,e);0==i.Level&&(i.State.SiblingsRowV=new f(i.State.Top,i.State.Bottom)),null!=i.AssistantsRoot&&(B.CopyExteriorFrom(i.AssistantsRoot.State,i.State),B.VerticalLayout(t,i.AssistantsRoot));let o=new f(i.State.SiblingsRowV.From,null==i.AssistantsRoot?i.State.SiblingsRowV.To:i.State.BranchExterior.Bottom);for(let e=0;e<i.State.NumberOfSiblingRows;e++){let n=f.MinMax(),r=0==e?this.ParentChildSpacing:this.SiblingSpacing,s=e*i.State.NumberOfSiblingColumns,a=Math.min(s+i.State.NumberOfSiblingColumns,i.State.NumberOfSiblings);for(let t=s;t<a;t++){let e=i.Children[t];if(e.Element.IsSpecial)continue;let s=e.State,a=o.To+r;B.MoveTo(e.State,s.Left,a),e.State.BranchExterior=p.from(e.State.Size,e.State.TopLeft),n=f.add(n,new f(a,a+s.Size.Height))}n=new f(n.From,n.To);let l=Number.MIN_VALUE;for(let e=s;e<a;e++){let o=i.Children[e];o.State.SiblingsRowV=n,B.VerticalLayout(t,o),l=Math.max(l,o.State.BranchExterior.Bottom)}o=new f(n.From,Math.max(l,n.To));let h=s+Math.floor(i.State.NumberOfSiblingColumns/2);if(h<i.State.NumberOfSiblings){let t=e==i.State.NumberOfSiblingRows-1?i.Children[h-1].State.SiblingsRowV.To:o.To,n=i.Children[h].State;B.AdjustSpacer(n,0,o.From,this.ParentConnectorShield,t-o.From)}}}ApplyHorizontalLayout(t,e){let i=e.BranchRoot;if(i.State.NumberOfSiblings<=this.MaxSiblingsPerRow)return void super.ApplyHorizontalLayout(t,e);null!=i.AssistantsRoot&&B.HorizontalLayout(t,i.AssistantsRoot);for(let o=0;o<i.State.NumberOfSiblingColumns;o++){for(let e=0;e<i.State.NumberOfSiblingRows;e++){let n=e*i.State.NumberOfSiblingColumns+o;if(n>=i.State.NumberOfSiblings)break;let r=i.Children[n];B.HorizontalLayout(t,r)}B.AlignHorizontalCenters(t,e,this.EnumerateColumn(i,o))}let o=i.State,n=i.Children[Math.floor(i.State.NumberOfSiblingColumns/2)].State.CenterH,r=o.CenterH-n;B.MoveChildrenOnly(t,e,r);let s=i.Children[i.State.NumberOfSiblings];B.AdjustSpacer(s.State,o.CenterH-this.ParentConnectorShield/2,o.Bottom,this.ParentConnectorShield,i.Children[0].State.SiblingsRowV.From-o.Bottom),t.MergeSpacer(s);let a=this.ParentChildSpacing;for(let e=0;e<i.State.NumberOfSiblings;e+=i.State.NumberOfSiblingColumns){let o=i.Children[e].State,n=i.Children[Math.min(e+i.State.NumberOfSiblingColumns-1,i.State.NumberOfSiblings-1)].State,r=i.Children[1+i.State.NumberOfSiblings+Math.floor(e/i.State.NumberOfSiblingColumns)],l=n.Right>=s.State.Right?n.Right-o.Left:s.State.Right-o.Left;B.AdjustSpacer(r.State,o.Left,o.SiblingsRowV.From-a,l,a),t.MergeSpacer(r),a=this.SiblingSpacing}}EnumerateColumn(t,e){const i=[];for(let o=0;o<t.State.NumberOfSiblingRows;o++){let n=o*t.State.NumberOfSiblingColumns+e;if(n>=t.State.NumberOfSiblings)break;i.push(t.Children[n])}return i}RouteConnectors(t,e){if(e.State.NumberOfSiblings<=this.MaxSiblingsPerRow)return void super.RouteConnectors(t,e);let i=1+e.State.NumberOfSiblingRows;for(let t of e.Children)t.Element.IsSpecial||i++;let o=[],n=e.State,r=n.CenterH,s=e.Children[e.State.NumberOfSiblings-1].State.SiblingsRowV.From-this.ChildConnectorHookLength-n.Bottom;o[0]=new L(new g(r,n.Bottom),new g(r,n.Bottom+s));let a=1;for(let t=0;t<e.State.NumberOfSiblings;t++){let i=e.Children[t];if(!i.Element.IsSpecial){let t=i.State,e=t.CenterH;o[a++]=new L(new g(e,t.Top),new g(e,t.Top-this.ChildConnectorHookLength))}}let l=i-e.State.NumberOfSiblingRows-1;for(let t=1;t<i-e.State.NumberOfSiblingRows;t+=this.MaxSiblingsPerRow){let e=o[t],i=o[Math.min(t+this.MaxSiblingsPerRow-1,l)];i.From.X<o[0].From.X?o[a++]=new L(new g(e.To.X,e.To.Y),new g(o[0].To.X,e.To.Y)):o[a++]=new L(new g(e.To.X,e.To.Y),new g(i.To.X,e.To.Y))}e.State.Connector=new y(o)}}class q extends m{constructor(){super(...arguments),this.GetSupportsAssistants=()=>!1,this.MaxOnLeft=t=>Math.floor(t.State.NumberOfSiblings/2)+t.State.NumberOfSiblings%2,this.NeedCarrierProtector=t=>{var e;return 0==(null==(e=t.ParentNode)?void 0:e.ChildCount)}}PreProcessThisNode(t,e){if(e.State.NumberOfSiblings=e.ChildCount,e.State.NumberOfSiblings>0){e.State.NumberOfSiblingColumns=1,e.State.NumberOfSiblingRows=Math.floor(e.State.NumberOfSiblings/2),e.State.NumberOfSiblings%2!=0&&e.State.NumberOfSiblingRows++;var i=s.Special(s.None,e.Element.Id,!1);e.AddRegularChildBox(i)}}ApplyVerticalLayout(t,e){const i=e.BranchRoot;if(0==i.Level)throw new Error("Should never be invoked on root node");if(null==i.State.SiblingsRowV)throw Error("SiblingsRowV is null");let o=i.State.SiblingsRowV.To;const n=this.MaxOnLeft(i);for(var r=0;r<n;r++){const e=0==r?this.ParentChildSpacing:this.SiblingSpacing,s=i.Children[r],a=s.State;B.MoveTo(a,a.Left,o+e);let l=new f(a.Top,a.Bottom);const h=r+n;if(null==a.Size)throw Error("Size is null");if(h<i.State.NumberOfSiblings){const n=i.Children[h],r=n.State;if(B.MoveTo(r,r.Left,o+e),null==r.Size)throw Error("Size is null");r.Bottom>a.Bottom?B.MoveTo(a,a.Left,r.CenterV-a.Size.Height/2):r.Bottom<a.Bottom&&B.MoveTo(r,r.Left,a.CenterV-r.Size.Height/2),r.BranchExterior=p.from(r.Size,r.TopLeft),l=f.add(l,new f(r.Top,r.Bottom)),r.SiblingsRowV=l,B.VerticalLayout(t,n),o=r.BranchExterior.Bottom}a.BranchExterior=p.from(a.Size,a.TopLeft),a.SiblingsRowV=l,B.VerticalLayout(t,s),o=Math.max(o,a.BranchExterior.Bottom)}}ApplyHorizontalLayout(t,e){var i=e.BranchRoot;0==i.Level&&(i.State.SiblingsRowV=new f(i.State.Top,i.State.Bottom));for(var o=!0,n=0,r=this.MaxOnLeft(i),s=0;s<i.State.NumberOfSiblings;s++){var a=i.Children[s];if(B.HorizontalLayout(t,a),++n==r&&o){B.AlignHorizontalCenters(t,e,this.EnumerateSiblings(i,0,r)),o=!1,n=0;for(var l=Number.MIN_VALUE,h=0;h<=s;h++)l=Math.max(l,i.Children[h].State.BranchExterior.Right);if(i.State.NumberOfSiblings%2!=0)l=Math.max(l,a.State.Right);else{var u=i.Children[i.State.NumberOfSiblings-1];l=u.Element.IsCollapsed||0==u.ChildCount?Math.max(l,a.State.Right):Math.max(l,a.State.BranchExterior.Right)}const S=i.Children[i.State.NumberOfSiblings];B.AdjustSpacer(S.State,l,i.State.Bottom,this.ParentConnectorShield,i.State.BranchExterior.Bottom-i.State.Bottom),e.Boundary.MergeFromNode(S)}}if(B.AlignHorizontalCenters(t,e,this.EnumerateSiblings(i,r,i.State.NumberOfSiblings)),i.Level>0&&i.State.NumberOfSiblings>0){let o=i.Children[i.State.NumberOfSiblings].State.CenterH;const n=i.State.CenterH-o;B.MoveChildrenOnly(t,e,n)}}RouteConnectors(t,e){var i=e.State.NumberOfSiblings;if(0!=i){this.NeedCarrierProtector(e)&&i++;for(var o=[],n=0,r=this.MaxOnLeft(e),s=e.Children[e.State.NumberOfSiblings].State,a=s.CenterH,l=!0,h=0,u=Number.MIN_VALUE,S=0;S<e.State.NumberOfSiblings;S++){var d=l?e.Children[S].State.Right:e.Children[S].State.Left,c=e.Children[S].State.CenterV;u=Math.max(u,c),o[n++]=new L(new g(a,c),new g(d,c)),++h==r&&(h=0,l=!l)}this.NeedCarrierProtector(e)&&(o[e.State.NumberOfSiblings]=new L(new g(s.CenterH,s.Top),new g(s.CenterH,u))),e.State.Connector=new y(o)}}EnumerateSiblings(t,e,i){const o=[];for(var n=e;n<i;n++)o.push(t.Children[n]);return o}}class j{constructor(){this.suppressRootBox=!1,this.totalBoxCount=20,this.percentAssistants=10,this.onLayoutStateChanged=(t,e)=>{t.CurrentOperation===d.PreprocessVisualTree&&this.renderBoxes()},this.buildChart(!0)}boxClick(t){const e=this.diagram.Boxes.BoxesById.get(t);e.IsCollapsed=!e.IsCollapsed,this.positionBoxes()}buildChart(t){t&&this.initDiagram(),this.positionBoxes()}collapseAllBoxes(t,e){for(const i of t.BoxesByDataId.values())i.IsSpecial||(i.IsCollapsed=e)}generateData(){const t=this.totalBoxCount,e=this.percentAssistants,i=new V;if((new H).GenerateDataItems(i,t,e),this.suppressRootBox){i.Items.delete("0");for(const t of i.Items.values())"0"===t.ParentId&&(t.ParentId=null)}return i}initDiagram(){$("#myDiagramDiv").html('<div id="myConnectors" class="chartConnectorsPlane"/>');const t=this.generateData();this.dataSource=t;const e=new a(t);$("#CollapseAllOnRebuild")[0].checked&&this.collapseAllBoxes(e,!0);const i=this.diagram=new n;i.Boxes=e;const o=new x;o.ParentAlignment=c.Center,i.LayoutSettings.LayoutStrategies.set("linear",o);let r=new Y;r.ParentAlignment=c.Center,r.MaxSiblingsPerRow=2,i.LayoutSettings.LayoutStrategies.set("hanger2",r),r=new Y,r.ParentAlignment=c.Center,r.MaxSiblingsPerRow=4,i.LayoutSettings.LayoutStrategies.set("hanger4",r);let s=new P;s.ParentAlignment=c.Right,i.LayoutSettings.LayoutStrategies.set("singleColumnRight",s),s=new P,s.ParentAlignment=c.Left,i.LayoutSettings.LayoutStrategies.set("singleColumnLeft",s);let l=new M;l.ParentAlignment=c.Center,l.MaxGroups=1,i.LayoutSettings.LayoutStrategies.set("fishbone1",l),l=new M,l.ParentAlignment=c.Center,l.MaxGroups=2,i.LayoutSettings.LayoutStrategies.set("fishbone2",l);let h=new A;h.ParentAlignment=c.InvalidValue,h.Orientation=O.SingleRowHorizontal,h.ParentChildSpacing=10,i.LayoutSettings.LayoutStrategies.set("hstack",h);let u=new A;u.ParentAlignment=c.InvalidValue,u.Orientation=O.SingleColumnVertical,u.ParentChildSpacing=10,i.LayoutSettings.LayoutStrategies.set("vstack",u),u=new A,u.ParentAlignment=c.InvalidValue,u.Orientation=O.SingleColumnVertical,u.SiblingSpacing=20,i.LayoutSettings.LayoutStrategies.set("vstackMiddle",u),u=new A,u.ParentAlignment=c.InvalidValue,u.Orientation=O.SingleColumnVertical,u.SiblingSpacing=50,i.LayoutSettings.LayoutStrategies.set("vstackTop",u);let S=new q;S.ParentAlignment=c.Center,i.LayoutSettings.LayoutStrategies.set("assistants",S),i.LayoutSettings.DefaultLayoutStrategyId="fishbone1",i.LayoutSettings.DefaultAssistantLayoutStrategyId="assistants"}getBoxLevel(t,e){let i=0;for(;e.ParentId>0;){const o=t.BoxesById.get(e.ParentId);if(!o)break;e=o,i++}return i}renderBoxes(){let t=this.diagram.Boxes,e=this.dataSource;const i=[],o=[];this.diagram.VisualTree.IterateParentFirst(n=>{let r=n.Element;if(r.IsDataBound){let s=$("#box"+r.Id);if(s.length>0){let t=$("#exp"+r.Id);return n.State.IsHidden?(s.hide(),t.length>0&&t.hide()):(s.show(),t.length>0&&t.show()),!0}if(n.State.IsHidden)return!0;let a=this.getBoxLevel(t,r);e.GetDataItem(r.DataId);const l={1:"chartBoxTop",2:"chartBoxMiddle",3:"chartBoxLower"}[a]||"chartBoxLowest",h={1:"Top",2:"Middle",3:"Lower"}[a]||a,u=document.createElement("div");if(u.className=l,u.id="box"+r.Id,u.style.position="absolute",u.style.width="150px",u.style.height="auto",u.innerText=`${h} - Box #${r.Id}, Data #${r.DataId}, Asst: ${r.IsAssistant}`,u.addEventListener("click",()=>this.boxClick(r.Id)),i.push(u),n.ChildCount>0||null!=n.AssistantsRoot){const t=document.createElement("div");t.id="exp"+r.Id,t.className="expander",t.addEventListener("click",()=>this.boxClick(r.Id)),o.push(t)}r.Size=this.getBoxElementSize(r.Id)}return!0});const n=document.querySelector("#myDiagramDiv");for(const t of o)n.appendChild(t);for(const t of i)n.appendChild(t)}getBranchOptimizerName(t){const e=document.querySelector("input[name='SelectBranchOptimizer']:checked");return(this["branchOptimizer"+(null==e?void 0:e.value)]||this.branchOptimizerAllLinear)(t)}branchOptimizerAllLinear(t){return t.IsAssistantRoot?null:"linear"}branchOptimizerAllHanger2(t){return t.IsAssistantRoot?null:"hanger2"}branchOptimizerAllHanger4(t){return t.IsAssistantRoot?null:"hanger4"}branchOptimizerAllFishbone1(t){return t.IsAssistantRoot?null:"fishbone1"}branchOptimizerAllFishbone2(t){return t.IsAssistantRoot?null:"fishbone2"}branchOptimizerAllSingleColumnLeft(t){return t.IsAssistantRoot?null:"singleColumnRight"}branchOptimizerAllSingleColumnRight(t){return t.IsAssistantRoot?null:"singleColumnLeft"}branchOptimizerStackers(t){return t.IsAssistantRoot?null:0===t.Level?"vstackTop":1===t.Level?"vstackMiddle":"hstack"}branchOptimizerSmart(t){if(t.IsAssistantRoot)return null;let e=t.ChildCount;if(e<=1)return"vstack";let i=0;for(let o=0;o<e;o++)t.Children[o].ChildCount>0&&i++;return i<=1?e<=4?"vstack":e<=8?"fishbone1":"fishbone2":"hanger4"}boxSizeFunc(t){let e=this.diagram.Boxes.BoxesByDataId.get(t).Id;return this.diagram.Boxes.BoxesById.get(e).Size}getBoxElementSize(t){return new r(160,50)}positionBoxes(){$("#myConnectors").html("");this.diagram.Boxes,this.dataSource;let t=this.diagram,e=new X(t);e.OperationChanged=this.onLayoutStateChanged,e.BoxSizeFunc=t=>this.boxSizeFunc(t),e.LayoutOptimizerFunc=t=>this.getBranchOptimizerName(t),console.log("positionBoxes"),B.Apply(e);const i=B.ComputeBranchVisualBoundingRect(t.VisualTree),o=document.querySelector("#myDiagramDiv");if(null==o)throw Error("Cannot find #myDiagramDiv");o.style.width=i.Size.Width+"px",o.style.height=i.Size.Height+"px";let n=-i.Left,r=-i.Top;const s=[];t.VisualTree.IterateParentFirst((function(t){if(t.State.IsHidden)return!1;let e=t.Element;if(e.IsDataBound){const i=document.querySelector("#box"+e.Id);if(i){let o=t.State.TopLeft.X+n,s=t.State.TopLeft.Y+r;if(i.style.left=o+"px",i.style.top=s+"px",i.style.width=t.State.Size.Width+"px",i.style.height=t.State.Size.Height+"px",t.ChildCount>0||null!=t.AssistantsRoot){const i=document.querySelector("#exp"+e.Id);i&&(o=t.State.Right+n-15,s=t.State.Bottom+r-15,i.style.left=o+"px",i.style.top=s+"px",e.IsCollapsed?i.innerText="":i.innerText="")}}}if(null!=t.State.Connector)for(let e=0;e<t.State.Connector.Segments.length;e++){let i,o,a,l,h=t.State.Connector.Segments[e];h.From.Y===h.To.Y?(i="chartHLine",l=1,h.From.X<h.To.X?(o=h.From,a=h.To.X-h.From.X):(o=h.To,a=h.From.X-h.To.X)):(i="chartVLine",a=1,h.From.Y<h.To.Y?(o=h.From,l=h.To.Y-h.From.Y):(o=h.To,l=h.From.Y-h.To.Y)),t.IsAssistantRoot&&(i+="Dotted");const u=document.createElement("div");u.className=i,u.style.top=o.Y+r+"px",u.style.left=o.X+n+"px",u.style.width=a+"px",u.style.height=l+"px",s.push(u)}return!0}));const a=document.querySelector("#myConnectors");for(const t of s)a.appendChild(t)}}document.addEventListener("DOMContentLoaded",()=>{if(console.log("loaded!"),window.chartApp)return;const t=window.chartApp=new j;window.changedSuppressRootBox=function(e){t.suppressRootBox=e.checked,t.buildChart(!0)},window.clickCollapseAll=function(e){t.collapseAllBoxes(t.diagram.Boxes,!0),t.buildChart(!1)},window.clickExpandAll=function(e){t.collapseAllBoxes(t.diagram.Boxes,!1),t.buildChart(!1)},window.clickOptimizer=function(e){t.buildChart(!1)},window.clickDataCounts=function(e){let i=e.value;"small"===i?(t.totalBoxCount=20,t.percentAssistants=0):"small-a"===i?(t.totalBoxCount=20,t.percentAssistants=10):"large"===i?(t.totalBoxCount=200,t.percentAssistants=0):"large-a"===i?(t.totalBoxCount=200,t.percentAssistants=10):"huge-a"===i&&(t.totalBoxCount=1e3,t.percentAssistants=5),t.buildChart(!0)}})}});
//# sourceMappingURL=spec.js.map